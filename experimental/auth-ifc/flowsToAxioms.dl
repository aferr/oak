#ifndef FLOWSTO_AXIOMS 
#define FLOWSTO_AXIOMS
.type principal <: symbol

// These rules are inspired by the rules from FLAM. However,
// here the "speaksFor" order is called "trusts" because it may be 
// more intuitive.

.decl isPrincipal(p: principal)
// p trusts q
.decl trusts(p: principal, q: principal)
// p trusts q to protect p's confidentiality
.decl trustsConf(p: principal, q: principal)
// p trusts q to protect p's integrity
.decl trustsInteg(p: principal, q: principal)

trusts(p, p) :- isPrincipal(p).
trusts(p, r) :- trusts(p, q), trusts(q, r).

// trusts implies trust on subjects
trustsConf(p, q) :- trusts(p, q).
trustsInteg(p, q) :- trusts(p, q).

trustsConf(p, r) :- trustsConf(p, q), trustsConf(q, r).
trustsInteg(p, r) :- trustsInteg(p, q), trustsInteg(q, r).

// top, bottom principals in trust lattice NOT IFC lattice
// top = (secret, trusted)
// bot = (public, untrusted)
// so we do not have bot flowsTo top
// (The IFC lattice is the same as the trusts lattice rotated 90 degrees. If 
// this is confusing, just ignore!)

isPrincipal("top").
isPrincipal("bot").
trusts(p, "top") :- isPrincipal(p).
trusts("bot", p) :- isPrincipal(p).

.decl flowsTo(p: principal, q: principal)
// to allow data movement from p to q
// p must trust q to protect p's confidentiality
// q must trust p to protect q's integrity
flowsTo(p, q) :- 
    trustsConf(p, q), 
    trustsInteg(q, p).

#endif // FLOWSTO_AXIOMS
