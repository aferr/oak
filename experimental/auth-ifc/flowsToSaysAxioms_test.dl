#include "flowsToSaysAxioms.dl"

.output trusts
.output flowsTo

isPrincipal("p").
isPrincipal("q").
isPrincipal("r").

//-----------------------------------------------------------------------------
// Basic Example
//-----------------------------------------------------------------------------

// note that, for example, "p" cannot forge a statement like "q says p trusts 
// q" because this statement is also translated into a serialized object signed 
// using q's private key.
trustsConf("p", "p", "q").
trustsInteg("q", "q", "p").
// together with the axioms these imply 
// flowsTo(top, p, q).

//-----------------------------------------------------------------------------
// A slightly more complicated example
//-----------------------------------------------------------------------------

isPrincipal("x").
isPrincipal("y").
isPrincipal("auditorX").
isPrincipal("differentialPrivacyTool").

// s says is_buffer_overflow_free
// p is a piece of software. 
.decl is_buffer_overflow_free(s: principal, p: principal)
.decl is_differentially_private(s: principal, p: principal)

// x is willing to trust the confidentiality of
// any process that x can be convinced is differentially 
// private
trustsConf("x", "x", p) :-
    is_differentially_private("x", p).

// y is willing to trust the integrity of any process that R can be convinced 
// is free of buffer overflows
trustsInteg("y", "y", p) :-
    is_buffer_overflow_free("y", p).

// The following rules should make it possible to prove x flowsTo y

// x delegates to tool just on the subject of differential privacy
is_differentially_private("x", p) :-
    isPrincipal(p),
    is_differentially_private("differentialPrivacyTool", p).

// tool says y is differentially private
is_differentially_private("differentialPrivacyTool", "y").

// In the real implementation, the following would not show up in the policy,
// but this would instead get generated by the compiler for every user-defined
// relation:
is_buffer_overflow_free(s, p) :-
    trusts("top", s, q),
    is_buffer_overflow_free(q, p).

// X delegates to auditorX about everything. x is not willing to look at any 
// code
trusts("y", "y", "auditorX").

// auditor inspects code in "y" and says that it is buffer-overflow free.
is_buffer_overflow_free("auditorX", "x").

.output is_differentially_private
.output is_buffer_overflow_free
