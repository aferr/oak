#ifndef FLOWSTO_SAYS_AXIOMS
#define FLOWSTO_SAYS_AXIOMS
.type principal <: symbol

.decl isPrincipal(p: principal)

// The proposition "p says some_relation(x, y, z)" is encoded by just adding
// an extra argument to the relation like: "some_relation(p, x, y, z)". The
// idea is that we would extend the frontent of a datalog implementation to
// inclue this syntax and translate it into standard datalog.
//
// The trust ordering may copy beliefs among principals. Axioms needed to do 
// this would be generated by our extended datalog implementaiton.
//
// By convention "s" is the speaker in this file.

// this is "s says (p trusts q)", similar for others.
.decl trusts(s: principal, p: principal, q: principal)
.decl trustsConf(s: principal, p: principal, q: principal)
.decl trustsInteg(s: principal, p: principal, q: principal)

// top, bottom principals in trust lattice NOT IFC lattice
// top = (secret, trusted)
// bot = (public, untrusted)
// so we do not have bot flowsTo top
// (The IFC lattice is the same as the trusts lattice rotated 90 degrees. If 
// this is confusing, just ignore!)

isPrincipal("top").
isPrincipal("bot").

// "top" is ground truth on all facts. Everyone believes what top says. The 
// system makes decisions based on what "top" believes.
// "bot" believes everyone else about whatever they say.
//
// To allow data movement from p to q, we need to prove:
// flowsTo("top", p, q).

// symmetry
trusts(s, p, p) :- isPrincipal(s), isPrincipal(p).
// transitivity
trusts(s, p, r) :- trusts(s, p, q), trusts(s, q, r).
// antisymmetry not clearly needed yet
// definitions of meet / join and related axioms also not needed yet.

// All principals are authoritative about whom they trust.
trusts("top", p, q) :- trusts(p, p, q).
trustsConf("top", p, q) :- trustsConf(p, p, q).
trustsInteg("top", p, q) :- trustsInteg(p, p, q).

// trusts implies trust on subjects
trustsConf(s, p, q) :- trusts(s, p, q).
trustsInteg(s, p, q) :- trusts(s, p, q).

trustsConf(s, p, r) :- trustsConf(s, p, q), trustsConf(s, q, r).
trustsInteg(s, p, r) :- trustsInteg(s, p, q), trustsInteg(s, q, r).

// All principals believe that all principals believe top about everything
trusts(s, p, "top") :- isPrincipal(s), isPrincipal(p).
// All principals believe that bottom believes all principals about everything
trusts(s, "bot", p) :- isPrincipal(s), isPrincipal(p).

// To re-iterate, in order to allow data movement from p to q,
// we must be able to prove: flowsTo(top, p, q)
.decl flowsTo(s: principal, p: principal, q: principal)

// to allow data movement from p to q
// p must trust q to protect p's confidentiality
// q must trust p to protect q's integrity
flowsTo(s, p, q) :- 
    trustsConf(s, p, q), 
    trustsInteg(s, q, p).

#endif // FLOWSTO_AXIOMS
