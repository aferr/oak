#include "flatModules.dl"

#ifndef LABEL_CHECKING
#define LABEL_CHECKING

.type label <: symbol
.decl isLabel(ell: label)
.decl flowsTo(ell1: label, ell2: label)

isLabel("top").
isLabel("bot").

flowsTo(ell, "top") :- isLabel(ell).
flowsTo("bot", ell) :- isLabel(ell).

// refl
flowsTo(p, p) :- isLabel(p).
// trans
flowsTo(p1, p3) :- flowsTo(p1, p2), flowsTo(p2, p3).
// no antisym

// maps locations to labels
// (if we need a notion of different label environments, we could encode that 
// by adding an env_name element here, and passing that name to other relations 
// like meets/joins over lists).
.decl labelEnvironment(loc: locationName, ell: label)
// true if ell is a lower bound of the labels in the list
.decl isMeetOverList(ell: label, ls: locationList)
// true if ell is an upper bound of the labels in the list
.decl isJoinOverList(ell: label, ls: locationList)

isMeetOverList(ell, $Cons(locx, $Nil())) :- 
    labelEnvironment(locx, ell1), flowsTo(ell, ell1).
isMeetOverList(ell, $Cons(locx, lsPrime)) :- 
    groundedList(lsPrime),
    labelEnvironment(locx, ell1),
    flowsTo(ell, ell1), isMeetOverList(ell, lsPrime).

isJoinOverList(ell, $Cons(locx, $Nil())) :- 
    labelEnvironment(locx, ell1), flowsTo(ell1, ell).
isJoinOverList(ell, $Cons(locx, lsPrime)) :- 
    groundedList(lsPrime),
    labelEnvironment(locx, ell1),
    flowsTo(ell1, ell), isJoinOverList(ell, lsPrime).

.decl flatModLabelChecks(fm: flatModule)
// True if the module label checks
flatModLabelChecks($FlatMod(reads, writes)) :- 
    isJoinOverList(readBound, reads),
    isMeetOverList(writeBound, writes),
    flowsTo(readBound, writeBound).

.decl moduleLabelChecks(n: moduleName)
moduleLabelChecks(n) :- bindModule(n, fm), flatModLabelChecks(fm).
    

// ground lowering rules
isLabel(ell) :- flowsTo(ell, _).
isLabel(ell) :- flowsTo(_, ell).
isLabel(ell) :- labelEnvironment(_, ell).

#endif // LABEL_CHECKING
